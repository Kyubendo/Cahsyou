/* eslint-disable node/no-unpublished-require */
'use strict';

const fs = require('fs');
const spawn = require('child_process').spawn;
const tmp = require('tmp');
const chalk = require('chalk');
const colorGreen = chalk.default.bgGreen;
const colorBlue = chalk.default.bgBlue;
const colorRed = chalk.default.bgRedBright;
const colorYellow = chalk.default.bgYellowBright;

module.exports = function devtoolsToVideo(args) {
  if (args.input === '') {
    messageError('Input file not defined. Did you forget to set -i?');
    throw new Error();
  }

  if (args.output === '') {
    messageError('Output file not defined. Did you forget to set -o?');
    throw new Error();
  }

  try {
    if (fs.existsSync(args.input)) {
      // just checking
    }
  } catch (error) {
    messageError('Input file does not appear to exist.');
    throw new Error();
  }

  let timeline;
  try {
    timeline = JSON.parse(fs.readFileSync(args.input, 'utf8'));
  } catch (error) {
    messageError(
      `Cannot parse ${args.input}. Maybe it's not a Chrome DevTools JSON file?`,
    );
    throw new Error();
  }

  const screenshots = timeline.filter(event => event.name === 'Screenshot');
  if (screenshots.length === 0) {
    messageError(
      'Trace contains no screenshots. Did you make sure screenshots were enabled before recording your trace?',
    );
    throw new Error();
  }

  messageInfo(
    ' STARTING UP ',
    'Checking environment and setting up params.',
    colorYellow,
  );

  // setup our video
  const framesPerSecond = args.frames || 45;
  const msPerFrame = Math.round(1000000 / framesPerSecond);

  // determine is this is a multipass
  let multipassVideo = false;

  // if we have no lable or clock, just dump the video
  let stageOneFileOutputName;
  stageOneFileOutputName = args.output;


  messageInfo(' CONVERT ', 'Spawning FFMPEG worker with open pipe.');
  const videoPassOne = spawn(
    'ffmpeg',
    [
      '-framerate',
      `${framesPerSecond}`,
      '-f',
      'image2pipe',
      '-i', '-',
      '-qscale', '0',
      '-codec', 'mpeg4',
      '-b:v', '800k',
      '-flags', '+mv4+aic',
      '-trellis', '2',
      '-cmp', '2',
      `${stageOneFileOutputName}`,
    ],
    {
      stdio: ['pipe', 'inherit', 'inherit'],
    },
);
  // we may have to repeat the same screenshot in our video because nothing
  // painted/changed during a specific period in the trace so we store a outside
  // reference
  let repeatBuffer;

  let timestampTarget = screenshots[0].ts;

  messageInfo(
    ' CONVERT ',
    'Begin piping screenshots from DevTools trace to FFMPEG.',
  );

  // Let's send some screenshots to the pipe This is largely a riff off of Kris
  // Selden's trace-to-mp4.js gist (mad props)
  // https://gist.github.com/krisselden/bf98fb0c192fcb73ed32e79c0a7972d2
  for (const screenshot of screenshots) {
    // loop frames until we've hit the next new frame

    // while (timestampTarget < screenshot.ts) {
    //   videoPassOne.stdin.write(repeatBuffer);
    //   timestampTarget += msPerFrame;
    // }

    // new frame, cache it and write to the pipe
    if (screenshot.args.snapshot !== '') {
      repeatBuffer = Buffer.from(screenshot.args.snapshot, 'base64');
      videoPassOne.stdin.write(repeatBuffer);
    }
    timestampTarget += msPerFrame;
  }

  // There is a case where the last frame is the main body render on some sites,
  // which results in a strange early cut of the video (well, it just looks
  // weird). Add 1 second of padding of the last frame
  for (let index = 0; index < framesPerSecond; index++) {
    videoPassOne.stdin.write(repeatBuffer);
  }

  // close the pipe
  videoPassOne.stdin.end();

  videoPassOne.on('close', () => {
      messageComplete(stageOneFileOutputName);
  });
};

function messageComplete(filename) {
  console.log(
    `${colorGreen(
      ' COMPLETE ',
    )} DevTools trace to video is now complete! You file ${filename} is ready`,
  );
}

function messageError(message) {
  console.log(`${colorRed(' ERROR ')} ${message}`);
}

function messageInfo(heading, message, color = colorBlue) {
  console.log(`${color(heading)} ${message}`);
}
